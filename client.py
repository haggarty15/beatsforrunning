from flask import Flask, request, jsonify, send_from_directory, session
from flask_cors import CORS
import requests
import os
from dotenv import load_dotenv
from flask_bcrypt import Bcrypt
from flask_sqlalchemy import SQLAlchemy

load_dotenv()

app = Flask(__name__)
CORS(app)

# Configure Flask-Bcrypt and Flask-SQLAlchemy
bcrypt = Bcrypt(app)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
db = SQLAlchemy(app)

# Spotify API credentials
SPOTIFY_CLIENT_ID = os.getenv('CLIENT_ID')
SPOTIFY_CLIENT_SECRET = os.getenv('CLIENT_SECRET')
SPOTIFY_AUTH_URL = "https://accounts.spotify.com/api/token"
SPOTIFY_API_URL = "https://api.spotify.com/v1"
SPOTIFY_REDIRECT_URI = os.getenv('REDIRECT_URI', 'http://localhost:5000/callback')

# Database model for storing user information
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)

# Create the database tables
with app.app_context():
    db.create_all()

def get_spotify_token():
    print("Getting Spotify token ...")
    response = requests.post(
        SPOTIFY_AUTH_URL,
        {
            "grant_type": "client_credentials",
            "client_id": SPOTIFY_CLIENT_ID,
            "client_secret": SPOTIFY_CLIENT_SECRET,
        },
    )
    response_data = response.json()
    return response_data.get("access_token")


def fetch_audio_features(token, track_ids):
    """Return a mapping of track ID to audio features."""
    headers = {"Authorization": f"Bearer {token}"}
    url = f"{SPOTIFY_API_URL}/audio-features"
    resp = requests.get(url, headers=headers, params={"ids": ",".join(track_ids)})
    data = resp.json().get("audio_features", [])
    return {f["id"]: f for f in data if f}

@app.route('/')
def serve_index():
    print(f"Serving index.html from: {os.path.abspath('.')}")
    return send_from_directory('.', 'index.html')

@app.route('/favicon.ico')
def favicon():
    print(f"Serving favicon from: {os.path.abspath('.')}")
    return send_from_directory('.', 'favicon.ico')

@app.route('/songs', methods=['GET'])
def get_songs():
    """Return songs from Spotify matching the given artists/genres and pace."""
    artists = request.args.get('artists', '')
    genres = request.args.get('genres', '')
    pace = request.args.get('pace', type=float)

    token = get_spotify_token()
    headers = {"Authorization": f"Bearer {token}"}

    query_parts = []
    if artists:
        artist_terms = [f'artist:"{a.strip()}"' for a in artists.split(',') if a.strip()]
        query_parts.extend(artist_terms)
    if genres:
        genre_terms = [g.strip() for g in genres.split(',') if g.strip()]
        # Spotify search does not filter tracks by genre directly; include genres as plain terms
        query_parts.extend(genre_terms)
    query = ' '.join(query_parts) or 'music'

    search_url = f"{SPOTIFY_API_URL}/search"
    params = {"q": query, "type": "track", "limit": 20}
    resp = requests.get(search_url, headers=headers, params=params)
    items = resp.json().get('tracks', {}).get('items', [])

    track_ids = [t['id'] for t in items]
    features = fetch_audio_features(token, track_ids)

    desired_tempo = 240 / pace if pace else None
    songs = []
    for track in items:
        tempo = features.get(track['id'], {}).get('tempo')
        if desired_tempo and tempo:
            if abs(tempo - desired_tempo) > 15:
                continue
        songs.append({
            'title': track['name'],
            'artist': track['artists'][0]['name'],
            'tempo': tempo
        })

    return jsonify({'songs': songs})

# Query Reqs.
# Artist List OR Genre
# Pace OR BPM

@app.route('/search', methods=['GET'])
def search_spotify():
    query = request.args.get('query')
    search_type = request.args.get('type', 'artist')
    
    if not query:
        return jsonify({"error": "Query parameter is required"}), 400
    
    token = get_spotify_token()
    headers = {
        "Authorization": f"Bearer {token}"
    }
    
    search_url = f"{SPOTIFY_API_URL}/search"
    params = {
        "q": query,
        "type": search_type,
        "limit": 10
    }
    
    response = requests.get(search_url, headers=headers, params=params)
    return jsonify(response.json())


@app.route('/create_playlist', methods=['POST'])
def create_playlist():
    data = request.json
    user_id = data.get('user_id')
    playlist_name = data.get('name', 'New Playlist')
    token = data.get('token')
    
    if not user_id or not token:
        return jsonify({"error": "User ID and token are required"}), 400
    
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "name": playlist_name,
        "description": "Generated by the running playlist app",
        "public": False
    }
    
    playlist_url = f"{SPOTIFY_API_URL}/users/{user_id}/playlists"
    response = requests.post(playlist_url, headers=headers, json=payload)
    return jsonify(response.json())


@app.route('/social')
def serve_social():
    print(f"Serving social.html from: {os.path.abspath('.')}")
    return send_from_directory('.', 'social.html')

@app.route('/strava')
def serve_strava():
    print(f"Serving strava.html from: {os.path.abspath('.')}")
    return send_from_directory('.', 'strava.html')


@app.route('/login')
def login():
    scope = 'user-read-recently-played user-top-read playlist-modify-private'
    auth_url = (
        f"https://accounts.spotify.com/authorize?"
        f"client_id={SPOTIFY_CLIENT_ID}&"
        f"response_type=code&"
        f"redirect_uri={SPOTIFY_REDIRECT_URI}&"
        f"scope={scope}"
    )
    return jsonify({"auth_url": auth_url})

app.secret_key = os.getenv('SECRET_KEY', 'supersecretkey')

@app.route('/callback')
def callback():
    code = request.args.get('code')
    if not code:
        return jsonify({"error": "Authorization code not provided"}), 400

    token_response = requests.post(
        SPOTIFY_AUTH_URL,
        {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": SPOTIFY_REDIRECT_URI,
            "client_id": SPOTIFY_CLIENT_ID,
            "client_secret": SPOTIFY_CLIENT_SECRET,
        },
    )
    token_data = token_response.json()
    access_token = token_data.get('access_token')
    refresh_token = token_data.get('refresh_token')

    if not access_token:
        return jsonify({"error": "Failed to retrieve access token"}), 400

    # Store tokens in the session
    session['access_token'] = access_token
    session['refresh_token'] = refresh_token

    return jsonify({"message": "Logged in successfully"})

@app.route('/generate_playlist', methods=['POST'])
def generate_playlist():
    pace = request.json.get('pace')
    access_token = session.get('access_token')

    if not access_token:
        return jsonify({"error": "User not logged in"}), 401

    # Use the access token to fetch user data and generate a playlist
    headers = {"Authorization": f"Bearer {access_token}"}
    user_profile = requests.get(f"{SPOTIFY_API_URL}/me", headers=headers).json()

    # Stubbed response for playlist generation
    return jsonify({"message": "Playlist generated successfully", "user": user_profile, "pace": pace})

@app.route('/signup', methods=['POST'])
def signup():
    data = request.json
    username = data.get('username')
    email = data.get('email')
    password = data.get('password')

    if not username or not email or not password:
        return jsonify({"error": "All fields are required"}), 400

    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')
    new_user = User(username=username, email=email, password=hashed_password)

    try:
        db.session.add(new_user)
        db.session.commit()
        return jsonify({"message": "User registered successfully"}), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": "User registration failed"}), 400

@app.route('/user_login', methods=['POST'])
def user_login():
    data = request.json
    username = data.get('username')
    password = data.get('password')

    if not username or not password:
        return jsonify({"error": "All fields are required"}), 400

    user = User.query.filter_by(username=username).first()
    if user and bcrypt.check_password_hash(user.password, password):
        return jsonify({"message": "Login successful"}), 200
    else:
        return jsonify({"error": "Invalid credentials"}), 401


if __name__ == '__main__':
    print("Booting up BeatsForRunning ...")
    app.run(debug=True)
