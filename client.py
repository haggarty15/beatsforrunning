from flask import Flask, request, jsonify, send_from_directory, session, redirect
from flask_cors import CORS
import requests
import os
from dotenv import load_dotenv
from flask_bcrypt import Bcrypt
from flask_sqlalchemy import SQLAlchemy

load_dotenv()

app = Flask(__name__)
CORS(app)

# Configure Flask-Bcrypt and Flask-SQLAlchemy
bcrypt = Bcrypt(app)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
db = SQLAlchemy(app)

# Spotify API credentials
SPOTIFY_CLIENT_ID = os.getenv('CLIENT_ID')
SPOTIFY_CLIENT_SECRET = os.getenv('CLIENT_SECRET')
SPOTIFY_AUTH_URL = "https://accounts.spotify.com/api/token"
SPOTIFY_API_URL = "https://api.spotify.com/v1"
SPOTIFY_REDIRECT_URI = os.getenv('REDIRECT_URI', 'http://localhost:5000/callback')

# Database model for storing user information
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)

# Create the database tables
with app.app_context():
    db.create_all()

def get_spotify_token():
    print("Getting Spotify token ...")
    response = requests.post(
        SPOTIFY_AUTH_URL,
        {
            "grant_type": "client_credentials",
            "client_id": SPOTIFY_CLIENT_ID,
            "client_secret": SPOTIFY_CLIENT_SECRET,
        },
    )
    response_data = response.json()
    return response_data.get("access_token")


# Enhanced 'fetch_audio_features' to log track IDs and handle missing features
def fetch_audio_features(token, track_ids):
    """Return a mapping of track ID to audio features."""
    headers = {"Authorization": f"Bearer {token}"}
    url = f"{SPOTIFY_API_URL}/audio-features"

    print(f"Fetching audio features for track IDs: {track_ids}")

    resp = requests.get(url, headers=headers, params={"ids": ",".join(track_ids)})
    print(f"Audio features response status: {resp.status_code}")
    print(f"Audio features response body: {resp.text}")

    data = resp.json().get("audio_features", [])

    # Log each track's audio features for inspection
    for feature in data:
        print(f"Audio feature for track: {feature}")

    # Handle cases where some tracks may not have audio features
    features = {}
    for feature in data:
        if feature:  # Ensure the feature is not None
            features[feature["id"]] = feature

    return features

@app.route('/')
def serve_index():
    print(f"Serving index.html from: {os.path.abspath('.')}")
    return send_from_directory('.', 'index.html')

@app.route('/favicon.ico')
def favicon():
    print(f"Serving favicon from: {os.path.abspath('.')}")
    return send_from_directory('.', 'favicon.ico')


# Query Reqs.
# Artist List OR Genre
# Pace OR BPM

@app.route('/search', methods=['GET'])
def search_spotify():
    query = request.args.get('query')
    search_type = request.args.get('type', 'artist')
    
    if not query:
        return jsonify({"error": "Query parameter is required"}), 400
    
    token = get_spotify_token()
    headers = {
        "Authorization": f"Bearer {token}"
    }
    
    search_url = f"{SPOTIFY_API_URL}/search"
    params = {
        "q": query,
        "type": search_type,
        "limit": 10
    }
    
    response = requests.get(search_url, headers=headers, params=params)
    return jsonify(response.json())


@app.route('/create_playlist', methods=['POST'])
def create_playlist():
    data = request.json
    user_id = data.get('user_id')
    playlist_name = data.get('name', 'New Playlist')
    token = data.get('token')
    
    if not user_id or not token:
        return jsonify({"error": "User ID and token are required"}), 400
    
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "name": playlist_name,
        "description": "Generated by the running playlist app",
        "public": False
    }
    
    playlist_url = f"{SPOTIFY_API_URL}/users/{user_id}/playlists"
    response = requests.post(playlist_url, headers=headers, json=payload)
    return jsonify(response.json())


@app.route('/social')
def serve_social():
    print(f"Serving social.html from: {os.path.abspath('.')}")
    return send_from_directory('.', 'social.html')

@app.route('/strava')
def serve_strava():
    print(f"Serving strava.html from: {os.path.abspath('.')}")
    return send_from_directory('.', 'strava.html')


# Update '/login' endpoint to include 'user-read-private' in the scope
@app.route('/login')
def login():
    scope = 'user-read-recently-played user-top-read playlist-modify-private user-read-private'
    auth_url = (
        f"https://accounts.spotify.com/authorize?"
        f"client_id={SPOTIFY_CLIENT_ID}&"
        f"response_type=code&"
        f"redirect_uri={SPOTIFY_REDIRECT_URI}&"
        f"scope={scope}"
    )
    return redirect(auth_url)

app.secret_key = os.getenv('SECRET_KEY', 'supersecretkey')

# Update '/callback' endpoint to redirect to the home page after login
@app.route('/callback')
def callback():
    code = request.args.get('code')
    if not code:
        print("Authorization code not provided")
        return jsonify({"error": "Authorization code not provided"}), 400

    print(f"Authorization code received: {code}")

    token_response = requests.post(
        SPOTIFY_AUTH_URL,
        {
            "grant_type": "authorization_code",
            "code": code,
            "redirect_uri": SPOTIFY_REDIRECT_URI,
            "client_id": SPOTIFY_CLIENT_ID,
            "client_secret": SPOTIFY_CLIENT_SECRET,
        },
    )

    print(f"Spotify token response status: {token_response.status_code}")
    print(f"Spotify token response body: {token_response.text}")

    token_data = token_response.json()
    access_token = token_data.get('access_token')
    refresh_token = token_data.get('refresh_token')

    if not access_token:
        print("Failed to retrieve access token")
        return jsonify({"error": "Failed to retrieve access token"}), 400

    # Store tokens in the session
    session['access_token'] = access_token
    session['refresh_token'] = refresh_token

    print(f"Access token set in session: {access_token}")

    # Redirect to the home page after successful login
    return redirect('/')

# Add token refreshing functionality
def refresh_spotify_token():
    refresh_token = session.get('refresh_token')
    if not refresh_token:
        print("No refresh token available in session")
        return None

    print("Refreshing Spotify access token...")
    response = requests.post(
        SPOTIFY_AUTH_URL,
        {
            "grant_type": "refresh_token",
            "refresh_token": refresh_token,
            "client_id": SPOTIFY_CLIENT_ID,
            "client_secret": SPOTIFY_CLIENT_SECRET,
        },
    )

    if response.status_code != 200:
        print(f"Failed to refresh token: {response.status_code}, {response.text}")
        return None

    token_data = response.json()
    access_token = token_data.get('access_token')
    if access_token:
        session['access_token'] = access_token
        print(f"New access token set in session: {access_token}")
    else:
        print("Failed to retrieve new access token")

    return access_token

# Ensure tempo is retrieved for each song and matched against pace
@app.route('/generate_playlist', methods=['POST'])
def generate_playlist():
    pace = float(request.json.get('pace')) if request.json.get('pace') else None
    access_token = session.get('access_token')

    print(f"Access token retrieved from session: {access_token}")

    if not access_token:
        return jsonify({"error": "User not logged in"}), 401

    # Fetch user's top tracks
    headers = {"Authorization": f"Bearer {access_token}"}
    top_tracks_url = f"{SPOTIFY_API_URL}/me/top/tracks"
    response = requests.get(top_tracks_url, headers=headers, params={"limit": 50})
    top_tracks = response.json().get('items', [])

    track_ids = [track['id'] for track in top_tracks]
    features = fetch_audio_features(access_token, track_ids)

    desired_tempo = 240 / pace if pace else None
    playlist = []
    for track in top_tracks:
        tempo = features.get(track['id'], {}).get('tempo')
        if desired_tempo and tempo:
            if abs(tempo - desired_tempo) > 15:
                continue
        playlist.append({
            'title': track['name'],
            'artist': track['artists'][0]['name'],
            'tempo': tempo
        })

    print(f"Generated playlist: {playlist}")

    return jsonify({'playlist': playlist})

@app.route('/signup', methods=['POST'])
def signup():
    data = request.json
    username = data.get('username')
    email = data.get('email')
    password = data.get('password')

    if not username or not email or not password:
        return jsonify({"error": "All fields are required"}), 400

    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')
    new_user = User(username=username, email=email, password=hashed_password)

    try:
        db.session.add(new_user)
        db.session.commit()
        return jsonify({"message": "User registered successfully"}), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": "User registration failed"}), 400

@app.route('/user_login', methods=['POST'])
def user_login():
    data = request.json
    username = data.get('username')
    password = data.get('password')

    if not username or not password:
        return jsonify({"error": "All fields are required"}), 400

    user = User.query.filter_by(username=username).first()
    if user and bcrypt.check_password_hash(user.password, password):
        return jsonify({"message": "Login successful"}), 200
    else:
        return jsonify({"error": "Invalid credentials"}), 401

# Add debugging to check session contents
@app.before_request
def log_session_contents():
    print(f"Session contents: {dict(session)}")

# Add a function to verify the token and its scopes using the '/me' endpoint
def verify_spotify_token():
    access_token = session.get('access_token')
    if not access_token:
        print("No access token available in session")
        return None

    print("Verifying Spotify access token...")
    headers = {"Authorization": f"Bearer {access_token}"}
    me_url = f"{SPOTIFY_API_URL}/me"
    response = requests.get(me_url, headers=headers)

    print(f"/me endpoint response status: {response.status_code}")
    print(f"/me endpoint response body: {response.text}")

    if response.status_code != 200:
        print("Failed to verify token")
        return None

    return response.json()

# Add a route to expose the verify_spotify_token function
@app.route('/verify_token', methods=['GET'])
def verify_token_route():
    result = verify_spotify_token()
    if result:
        return jsonify(result), 200
    else:
        return jsonify({"error": "Failed to verify token"}), 400

if __name__ == '__main__':
    print("Booting up BeatsForRunning ...")
    app.run(debug=True)
